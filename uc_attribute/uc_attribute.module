<?php
/**
 * @file
 * Ubercart Attribute module.
 *
 * Allows customers to buy slightly different products from the same listing.
 *
 * Many manufacturers provide options to their products. This module provides
 * a way for store administrators to consolidate these options into one product
 * instead of listing each combination separately.
 */

/**
 * Implements hook_menu().
 */
function uc_attribute_menu() {
  $items['admin/store/products/attributes'] = array(
    'title' => 'Attributes',
    'description' => 'Create and edit product attributes and options.',
    'page callback' => 'uc_attribute_admin',
    'access arguments' => array('administer attributes'),
    'weight' => -8,
    'file' => 'uc_attribute.admin.inc',
  );
  $items['admin/store/products/attributes/add'] = array(
    'title' => 'Add an attribute',
    'description' => 'Add a product attribute.',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('uc_attribute_form'),
    'access arguments' => array('administer attributes'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'uc_attribute.admin.inc',
  );
  $items['admin/store/products/attributes/%uc_attribute/edit'] = array(
    'title' => 'Edit attribute',
    'description' => 'Edit a product attribute.',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('uc_attribute_form', 4),
    'access arguments' => array('administer attributes'),
    'file' => 'uc_attribute.admin.inc',
  );
  $items['admin/store/products/attributes/%uc_attribute/delete'] = array(
    'title' => 'Delete attribute',
    'description' => 'Delete a product attribute.',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('uc_attribute_delete_confirm', 4),
    'access arguments' => array('administer attributes'),
    'file' => 'uc_attribute.admin.inc',
  );
  $items['admin/store/products/attributes/%uc_attribute/options'] = array(
    'title' => 'Options',
    'description' => "Edit a product attribute's options.",
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('uc_attribute_options_form', 4),
    'access arguments' => array('administer attributes'),
    'file' => 'uc_attribute.admin.inc',
  );
  $items['admin/store/products/attributes/%uc_attribute/options/add'] = array(
    'title' => 'Add an option',
    'description' => 'Add a product attribute option.',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('uc_attribute_option_form', 4, NULL),
    'access arguments' => array('administer attributes'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'uc_attribute.admin.inc',
  );
  $items['admin/store/products/attributes/%uc_attribute/options/%uc_attribute_option/edit'] = array(
    'title' => 'Edit option',
    'description' => 'Edit a product attribute option.',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('uc_attribute_option_form', 4, 6),
    'access arguments' => array('administer attributes'),
    'file' => 'uc_attribute.admin.inc',
  );
  $items['admin/store/products/attributes/%uc_attribute/options/%uc_attribute_option/delete'] = array(
    'title' => 'Delete option',
    'description' => 'Delete a product attribute option.',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('uc_attribute_option_delete_confirm', 4, 6),
    'access arguments' => array('administer attributes'),
    'file' => 'uc_attribute.admin.inc',
  );

  // Menu items for default product class attributes and options.
  $items['admin/store/products/classes/%uc_product_class/attributes'] = array(
    'title' => 'Attributes',
    'description' => 'Administer product class attributes.',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('uc_object_attributes_form', 4, 'class'),
    'access callback' => 'uc_attribute_product_class_access',
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
    'file' => 'uc_attribute.admin.inc',
  );
  // $items['admin/store/products/classes/%uc_product_class/attributes/add'] = array(
  //   'title' => 'Add an attribute',
  //   'description' => 'Add an attribute to this product.',
  //   'page callback' => 'backdrop_get_form',
  //   'page arguments' => array('uc_object_attributes_form', 1, 'class', 'add'),
  //   'access callback' => 'uc_attribute_product_class_access',
  //   'access arguments' => array(1),
  //   'type' => MENU_LOCAL_ACTION,
  //   'weight' => 1,
  //   'file' => 'uc_attribute.admin.inc',
  // );
  $items['admin/store/products/classes/%uc_product_class/options'] = array(
    'title' => 'Options',
    'description' => 'Administer product class options.',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('uc_object_options_form', 4, 'class'),
    'access callback' => 'uc_attribute_product_class_access',
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
    'file' => 'uc_attribute.admin.inc',
  );

  // Insert subitems into the edit node page for product types.
  $items['node/%node/edit/attributes'] = array(
    'title' => 'Attributes',
    'description' => 'Edit product attributes.',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('uc_object_attributes_form', 1, 'product', 'overview'),
    'access callback' => 'uc_attribute_product_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
    'file' => 'uc_attribute.admin.inc',
  );
  $items['node/%node/edit/attributes/add'] = array(
    'title' => 'Add an attribute',
    'description' => 'Add an attribute to this product.',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('uc_object_attributes_form', 1, 'product', 'add'),
    'access callback' => 'uc_attribute_product_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_ACTION,
    'weight' => 1,
    'file' => 'uc_attribute.admin.inc',
  );
  $items['node/%node/edit/options'] = array(
    'title' => 'Options',
    'description' => 'Administer product attribute options.',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('uc_object_options_form', 1, 'product'),
    'access callback' => 'uc_attribute_product_option_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
    'file' => 'uc_attribute.admin.inc',
  );
  $items['node/%node/edit/adjustments'] = array(
    'title' => 'Adjustments',
    'description' => 'Administer SKU adjustments for different variants of this product.',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('uc_product_adjustments_form', 1),
    'access callback' => 'uc_attribute_product_option_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 3,
    'file' => 'uc_attribute.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_admin_paths().
 */
function uc_attribute_admin_paths() {
  $paths = array(
    'node/*/edit/attributes' => TRUE,
    'node/*/edit/attributes/add' => TRUE,
    'node/*/edit/options' => TRUE,
    'node/*/edit/adjustments' => TRUE,
  );

  return $paths;
}

/**
 * Access callback for editing a product class's attributes and options.
 */
function uc_attribute_product_class_access() {
  return user_access('administer product classes') && user_access('administer attributes');
}

/**
 * Access callback for editing a product's attributes.
 */
function uc_attribute_product_access($node) {
  if ($node->type == 'product_kit') {
    return FALSE;
  }

  return uc_product_is_product($node) && node_access('update', $node) && (user_access('administer attributes') || user_access('administer product attributes'));
}

/**
 * Access callback for editing a product's options.
 */
function uc_attribute_product_option_access($node) {
  if ($node->type == 'product_kit') {
    return FALSE;
  }

  return uc_product_is_product($node) && isset($node->attributes) && node_access('update', $node) && (user_access('administer attributes') || user_access('administer product attributes') || user_access('administer product options'));
}

/**
 * Implements hook_permission().
 */
function uc_attribute_permission() {
  return array(
    'administer attributes' => array(
      'title' => t('Administer attributes'),
    ),
    'administer product attributes' => array(
      'title' => t('Administer product attributes'),
    ),
    'administer product options' => array(
      'title' => t('Administer product options'),
    ),
  );
}

/**
 * Implements hook_theme().
 */
function uc_attribute_theme() {
  return array(
    'uc_attribute_option' => array(
      'variables' => array('option' => '', 'price' => ''),
      'file' => 'uc_attribute.theme.inc',
    ),
    'uc_attribute_add_to_cart' => array(
      'render element' => 'form',
      'file' => 'uc_attribute.theme.inc',
    ),
    'uc_object_attributes_form' => array(
      'render element' => 'form',
      'file' => 'uc_attribute.admin.inc',
    ),
    'uc_object_options_form' => array(
      'render element' => 'form',
      'file' => 'uc_attribute.admin.inc',
    ),
    'uc_attribute_options_form' => array(
      'render element' => 'form',
      'file' => 'uc_attribute.admin.inc',
    ),
    'uc_product_attributes' => array(
      'render element' => 'attributes',
      'file' => 'uc_attribute.admin.inc',
    ),
  );
}

/**
 * Implements hook_config_info().
 */
function uc_attribute_config_info() {
  $prefixes['uc_attribute.settings'] = array(
    'label' => t('Ubercart attribute settings'),
    'group' => t('Configuration'),
  );

  return $prefixes;
}

/**
 * Implements hook_form_FORM_ID_alter() for uc_product_settings_form().
 */
function uc_attribute_form_uc_product_settings_form_alter(&$form, &$form_state) {
  $form['attributes'] = array(
    '#type' => 'fieldset',
    '#title' => 'Attribute settings',
    '#group' => 'product-settings',
    '#weight' => -3,
  );
  $form['attributes']['uc_attribute_option_price_format'] = array(
    '#type' => 'radios',
    '#title' => t('Option price format'),
    '#default_value' => config_get('uc_attribute.settings', 'uc_attribute_option_price_format'),
    '#options' => array(
      'none' => t('Do not display'),
      'adjustment' => t('Display price adjustment'),
      'total' => t('Display total price'),
    ),
    '#description' => t('Determines how price variations are displayed to the customer. Prices may be displayed directly next to each attribute option in the attribute selection form either as a total price for the product with that option or as an adjustment (+ or -) showing how that option affects the product base price. Note that the price will always be displayed as an adjustment for attributes that can have multiple options (using checkboxes).'),
  );
  $form['#submit'][] = 'uc_attribute_form_uc_product_settings_form_submit';
}

/**
 * Submission function for our alterations to uc_product_settings_form().
 */
function uc_attribute_form_uc_product_settings_form_submit($form, &$form_state) {
  config_set('uc_attribute.settings', 'uc_attribute_option_price_format', $form_state['values']['uc_attribute_option_price_format']);
}

/**
 * Implements hook_module_implements_alter().
 *
 * Ensures that attribute form changes are made after (e.g.) product kits.
 */
function uc_attribute_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'uc_form_alter') {
    $group = $implementations['uc_attribute'];
    unset($implementations['uc_attribute']);
    $implementations['uc_attribute'] = $group;
  }
}

/**
 * Implements hook_uc_form_alter().
 *
 * Attaches option selectors to the form with the "Add to Cart" button.
 *
 * This function also handles selecting attributes for products added to orders
 * manually.
 */
function uc_attribute_uc_form_alter(&$form, &$form_state, $form_id) {
  if (strpos($form_id, 'add_to_cart_form') || $form_id == 'uc_order_add_product_form') {
    $use_ajax = strpos($form_id, 'add_to_cart_form') && config_get('uc_product.settings', 'uc_product_update_node_view');
    $node = &$form['node']['#value'];
    $id = $form_id . '-' . $node->nid . '-attributes';
    // If the node has a product list, add attributes to them.
    if (isset($form['products']) || isset($form['sub_products'])) {
      if (isset($form['products'])) {
        $element = &$form['products'];
      }
      else {
        $element = &$form['sub_products'];
      }
      foreach (element_children($element) as $key) {
        $element[$key]['attributes'] = _uc_attribute_alter_form($id . '-' . $key, $node->products[$key], $use_ajax);

        if (is_array($element[$key]['attributes'])) {
          $element[$key]['attributes']['#tree'] = TRUE;
          $element[$key]['#type'] = 'fieldset';
        }
      }
    }
    // If not, add attributes to the node.
    else {
      $form['attributes'] = _uc_attribute_alter_form($id, $node, $use_ajax);

      if (is_array($form['attributes'])) {
        $form['attributes']['#tree'] = TRUE;
        $form['attributes']['#weight'] = -1;
      }
    }
  }
}

/**
 * Implements hook_node_load().
 */
function uc_attribute_node_load($nodes, $types) {
  $product_types = array_intersect(uc_product_types(), $types);

  if (empty($product_types)) {
    return;
  }

  foreach ($nodes as &$node) {
    if (uc_product_is_product($node->type)) {
      $attributes = uc_product_get_attributes($node->nid);
      if (is_array($attributes) && !empty($attributes)) {
        $node->attributes = $attributes;
      }
    }
  }
}

/**
 * Implements hook_node_insert().
 */
function uc_attribute_node_insert($node) {
  // Set attributes from class attributes.
  $select = db_select('uc_class_attributes', 'ca')
    ->fields('ca', array(
      'aid',
      'label',
      'ordering',
      'required',
      'display',
      'default_option',
    ))
    ->condition('pcid', $node->type);
  // SELECT $node->nid AS nid.
  $select->addExpression(':nid', 'nid', array(':nid' => $node->nid));

  $config = config('uc_attribute.attributes');
  $class_attributes = $config->get("classes.{$node->type}");
  unset($class_attributes['options']);
  unset($class_attributes['pcid']);
  $class_attributes['nid'] = $node->nid;
  foreach ($class_attributes as $attribute) {
    db_insert('uc_product_attributes')
      ->fields($class_attributes)
      ->execute();
  }

  // db_insert('uc_product_attributes')
  //   ->from($select)
  //   ->execute();

  // Set options from class options.
  $select = db_select('uc_class_attribute_options', 'co')
    ->fields('co', array(
      'oid',
      'cost',
      'price',
      'weight',
      'ordering',
    ))
    ->condition('pcid', $node->type);
  $select->addExpression(':nid', 'nid', array(':nid' => $node->nid));

  $class_options = array();
  foreach($class_attributes as $class_attribute) {
    $class_attribute['options']['nid'] = $node->nid;
    unset($class_attribute['options']['oid']);
    unset($class_attribute['options']['pcid']);
    $class_options += $class_attribute['options'];
  }

  db_insert('uc_product_options')
    //->from($select)
    ->fields($class_options)
    ->execute();
}

/**
 * Implements hook_node_delete().
 */
function uc_attribute_node_delete($node) {
  db_delete('uc_product_options')
    ->condition('nid', $node->nid)
    ->execute();

  db_delete('uc_product_adjustments')
    ->condition('nid', $node->nid)
    ->execute();

  db_delete('uc_product_attributes')
    ->condition('nid', $node->nid)
    ->execute();
}

/**
 * Implements hook_node_update_index().
 */
function uc_attribute_node_update_index($node) {
  $output = '';

  $attributes = uc_product_get_attributes($node->nid);
  foreach ($attributes as $attribute) {
    $output .= '<h3>' . _uc_attribute_get_name($attribute) . '</h3>';

    foreach ($attribute->options as $option) {
      $output .= $option->name . ' ';
    }

    $output .= "\n";
  }

  $result = db_query("SELECT model FROM {uc_product_adjustments} WHERE nid = :nid", array(':nid' => $node->nid));
  while ($model = $result->fetchField()) {
    $output .= '<h2>' . $model . "</h2>\n";
  }

  return $output;
}

/**
 * Implements hook_uc_product_models().
 *
 * @param int $nid
 *   Node number for product type node.
 *
 * @return array
 *   Array of SKUs (model numbers) for this $nid.
 */
function uc_attribute_uc_product_models($nid) {
  // Get all the SKUs for all the attributes on this node.
  $models = db_query("SELECT DISTINCT model FROM {uc_product_adjustments} WHERE nid = :nid", array(':nid' => $nid))->fetchCol();

  return $models;
}

/**
 * Stores the customer's choices in the cart.
 */
function uc_attribute_uc_add_to_cart_data($form_values) {
  if (isset($form_values['attributes'])) {
    return array('attributes' => $form_values['attributes']);
  }
  else {
    return array('attributes' => array());
  }
}

/**
 * Implements hook_uc_order_product_alter().
 */
function uc_attribute_uc_order_product_alter(&$product, $order) {
  // Convert the attribute and option ids to their current names. This
  // preserves the important data in case the attributes or options are
  // changed later.
  if (!empty($product->data['attributes'])) {
    $attributes_keys = array_keys($product->data['attributes']);
    if (is_numeric(array_shift($attributes_keys))) {
      $attributes = array();
      $options = _uc_cart_product_get_options($product);
      foreach ($options as $aid => $option) {
        $attributes[$option['attribute']][$option['oid']] = $option['name'];
      }
      $product->data['attributes'] = $attributes;
    }
  }
}

/**
 * Implements hook_uc_product_class().
 */
function uc_attribute_uc_product_class($type, $op) {
  switch ($op) {
    case 'delete':
      $config = config('uc_attribute.attributes');
      $config->clear("classes.{$type}");
      $config->save();
      // db_delete('uc_class_attributes')
      //   ->condition('pcid', $type)
      //   ->execute();

      // db_delete('uc_class_attribute_options')
      //   ->condition('pcid', $type)
      //   ->execute();

      break;
  }
}

/**
 * Implements hook_uc_product_alter().
 */
function uc_attribute_uc_product_alter(&$node) {
  if (isset($node->data['attributes']) && is_array($node->data['attributes'])) {
    $options = _uc_cart_product_get_options($node);
    foreach ($options as $option) {
      $node->cost += $option['cost'];
      $node->price += $option['price'];
      $node->weight += $option['weight'];
    }

    $combination = array();
    foreach ($node->data['attributes'] as $aid => $value) {
      if (is_numeric($value)) {
        $attribute = uc_attribute_product_load($aid, $node->nid);
        if ($attribute && ($attribute->display == 1 || $attribute->display == 2)) {
          $combination[$aid] = $value;
        }
      }
    }
    ksort($combination);

    $model = db_query("SELECT model FROM {uc_product_adjustments} WHERE nid = :nid AND combination LIKE :combo", array(':nid' => $node->nid, ':combo' => serialize($combination)))->fetchField();

    if (!empty($model)) {
      $node->model = $model;
    }
  }
}

/**
 * Implements hook_uc_product_description().
 */
function uc_attribute_uc_product_description($product) {
  $description = array(
    'attributes' => array(
      '#product' => array(
        '#type' => 'value',
        '#value' => $product,
      ),
      '#theme' => 'uc_product_attributes',
      '#weight' => 1,
    ),
  );

  $desc = &$description['attributes'];

  // Cart version of the product has numeric attribute => option values so we
  // need to retrieve the right ones.
  $weight = 0;
  if (empty($product->order_id)) {
    foreach (_uc_cart_product_get_options($product) as $option) {
      if (!isset($desc[$option['aid']])) {
        $desc[$option['aid']]['#attribute_name'] = $option['attribute'];
        $desc[$option['aid']]['#options'] = array($option['name']);
      }
      else {
        $desc[$option['aid']]['#options'][] = $option['name'];
      }
      $desc[$option['aid']]['#weight'] = $weight++;
    }
  }
  elseif (isset($product->data['attributes'])) {
    foreach ($product->data['attributes'] as $attribute => $option) {
      $desc[] = array(
        '#attribute_name' => $attribute,
        '#options' => $option,
        '#weight' => $weight++,
      );
    }
  }

  return $description;
}

/**
 * Loads class attribute objects from the database.
 *
 * @param array $aids
 *   Attribute IDs to load.
 * @param int $pcid
 *   The ID of the class this attribute belongs to.
 *
 * @return array
 *   An array of loaded attributes.
 */
function uc_attribute_class_load_multiple(array $aids = array(), $pcid) {
  $config = config('uc_attribute.attributes');
  $class_attributes = array();
  foreach($aids as $aid) {
    $attr = $config->get("classes.{$pcid}.{$aid}");
    $attr['name'] = $config->get("attributes.{$aid}.name");
    $class_attributes[$aid] = (object) $attr;
  }

  // @todo order by ordering and name.
  backdrop_sort($result, array('ordering' => SORT_NUMERIC, 'name' => SORT_STRING));

  return $class_attributes;
}

/**
 * Loads product attribute objects from the database.
 *
 * @todo If we feel it necessary, we could optimize this, by inverting the
 * logic; that is, we could make uc_attribute load call this function and allow
 * this function to minimize the number of queries necessary. -cha0s
 *
 * @param array $aids
 *   Attribute IDs to load.
 * @param int $nid
 *   The ID of the product this attribute belongs to.
 *
 * @return array
 *   An array of loaded attributes.
 */
function uc_attribute_product_load_multiple(array $aids = array(), $nid = NULL) {
  // Seems like a big query to get attribute IDs, but it's all about the sort.
  // (I'm not sure if the default ordering is propagating down correctly here.
  // It appears that product/class attributes with no ordering won't let the
  // attribute's propagate down, as it does when loading. -cha0s)
  $query = db_select('uc_product_attributes', 'pa')
    ->fields('pa', array('aid'))
    ->condition("pa.nid", $nid);

  //$query->leftJoin('uc_attributes', 'ua', 'uca.aid = ua.aid');

  $query->orderBy('uca.ordering');
  //$query->orderBy('ua.name');

  // Filter by the attribute IDs requested.
  if (!empty($aids)) {
    // Sanity check - filter out non-numeric attribute IDs.
    $aids = array_filter($aids, 'is_numeric');
    $query->condition('pa.aid', $aids, 'IN');
  }

  $aids = $query->execute()->fetchCol();

  // Load the attributes.
  $attributes = array();
  foreach ($aids as $aid) {
    // Break this up.
    $attributes[$aid] = uc_attribute_load($aid, $nid);
  }

  return $attributes;
}

/**
 * Loads attribute objects from the database.
 *
 * @todo If we feel it necessary, we could optimize this, by inverting the
 * logic; that is, we could make uc_attribute load call this function and allow
 * this function to minimize the number of queries necessary. -cha0s
 *
 * @param array $aids
 *   Attribute IDs to load.
 * @param int $id
 *   The ID of the product/class this attribute belongs to.
 *
 * @return array
 *   An array of loaded attributes.
 */
function uc_attribute_global_load_multiple(array $aids = array(), $id = NULL) {
  $config = config('uc_attribute.attributes');
  $attributes = array();
  foreach($aids as $aid) {
    $attr = $config->get("attributes.{$aid}");
    $attributes[$aid] = (object) $attr;
  }

  // @todo order by ordering and name.
  backdrop_sort($attributes, array('ordering' => SORT_NUMERIC, 'name' => SORT_STRING));

  return $attributes;
}

/**
 * Loads an attribute.
 *
 * @param int $aid
 *   The ID of the attribute.
 * @param int $id
 *   The ID of the product/class this attribute belongs to.
  * @param string $type
 *   The type of attribute. 'product', or 'class'. Any other type will fetch
 *   a base attribute.
 *
 * @return object|false
 *   The attribute object, or FALSE if it doesn't exist.
 */
function uc_attribute_load($aid, $id = NULL, $type = '') {
  switch ($type) {
    case 'product':
      $attribute = uc_attribute_product_load($aid, $id);
      break;
    case 'class':
      $attribute = uc_attribute_class_load($aid, $id);
      break;
    default:
      $attribute = uc_attribute_global_load($aid);
      break;
  }

  return $attribute;
}

/**
 * Load attribute used in a class.
 *
 * @param int $aid
 *   The ID of the attribute.
 * @param int $pcid
 *   The ID of the class this attribute belongs to.
 *
 * @return object|false
 *   The attribute object, or FALSE if it doesn't exist.
 */
function uc_attribute_class_load($aid, $pcid) {
  $config = config('uc_attribute.attributes');
  $attribute = new stdClass();
  $class_attribute = $config->get("classes.{$pcid}.{$aid}");
  $attribute_global = $config->get("attributes.{$aid}");
  if ($class_attribute) {
    // @todo Sort options by ordering, name.
    $class_attribute['name'] = $attribute_global['name'];
    $attribute = (object) $class_attribute;
  }
  else {
    return FALSE;
  }

  if (isset($attribute->options)) {
    foreach ($attribute->options as $option) {
      $attribute->options[$option['oid']] = (object) $option;
    }
    //backdrop_sort($attribute->options, array('ordering' => SORT_NUMERIC, 'name' => SORT_STRING));
  }
  else {
    $attribute->options = array();
  }

  uc_attribute_translate($attribute);

  return $attribute;
}

/**
 * Loads an attribute from the database.
 *
 * @param int $aid
 *   The ID of the attribute.
 * @param int $id
 *   The ID of the product/class this attribute belongs to.
 *
 * @return object|false
 *   The attribute object, or FALSE if it doesn't exist.
 */
function uc_attribute_product_load($aid, $id = NULL) {
  // Read attribute data.
  $config = config('uc_attribute.attributes');

  $query = db_select('uc_product_attributes', 'pa')
    ->fields('pa', array('label', 'default_option', 'required', 'ordering', 'display', 'nid'));
  $query->condition('pa.nid', $id);

  $attribute = $query->execute()->fetchObject();

  // Don't try to build it further if it failed already.
  if (!$attribute) {
    return FALSE;
  }

  $attribute->aid = $aid;
  $attribute->name = $config->get("attributes.{$aid}.name");
  $attribute->description = $config->get("attributes.{$aid}.description");
  $attribute->default_label = $config->get("attributes.{$aid}.label");
  $attribute->default_ordering = $config->get("attributes.{$aid}.ordering");
  $attribute->default_required = $config->get("attributes.{$aid}.required");
  $attribute->default_display = $config->get("attributes.{$aid}.display");

  // Set any missing defaults.
  foreach (array('ordering', 'required', 'display', 'label') as $field) {
    if (isset($attribute->{"default_$field"}) && is_null($attribute->$field)) {
      $attribute->$field = $attribute->{"default_$field"};
    }
  }
  if (empty($attribute->label)) {
    $attribute->label = $attribute->name;
  }

  // Read option data.
  $query = db_select('uc_product_options', 'po')
    ->fields('po', array('nid', 'oid', 'cost', 'price', 'weight', 'ordering'));
  $result = $query->execute();

  // Got an attribute?
  if ($attribute) {
    // Get its options, too.
    $attribute->options = array();
    foreach ($result as $option) {
      $attribute->options[$option->oid] = $option;
      $attribute->options[$option->oid]->aid = $aid;
      $attribute->options[$option->oid]->name = $config->get("attributes.{$aid}.options.{$option->oid}.name");
    }
    uc_attribute_translate($attribute);
  }

  return $attribute;
}

/**
 * Loads an attribute.
 *
 * @param int $aid
 *   The ID of the attribute.
 * @return object|false
 *   The attribute object, or FALSE if it doesn't exist.
 */
function uc_attribute_global_load($aid) {
  $config = config('uc_attribute.attributes');
  $attribute = new stdClass();
  $global_attribute = $config->get("attributes.{$aid}");

  if ($global_attribute) {
    // @todo Sort options by ordering, name.
    $attribute = (object) $global_attribute;
  }
  else {
    return FALSE;
  }

  if (isset($attribute->options)) {
    foreach ($attribute->options as $option) {
      $attribute->options[$option['oid']] = (object) $option;
    }
  }
  else {
    $attribute->options = array();
  }

  uc_attribute_translate($attribute);

  return $attribute;
}

/**
 * Fetches an array of attribute objects that belong to a product.
 *
 * @param int $nid
 *   Product whose attributes to load.
 *
 * @return object[]
 *   The array of attribute objects.
 */
function uc_attribute_load_product_attributes($nid) {
  return uc_attribute_product_load_multiple(array(), $nid);
}

/**
 * Saves an attribute object to the database.
 *
 * @param object $attribute
 *   The attribute object to save.
 *
 * @return object
 *   The created attribute.
 */
function uc_attribute_save(&$attribute) {
  return uc_attribute_attribute_save($attribute);
}

/**
 * Save global attribute to config
 *
 * @param object $attribute
 *
 * @return object
 *   The created attribute.
 */
function uc_attribute_attribute_save($attribute) {
  $config = config('uc_attribute.attributes');
  // @todo make this use a unique name instead.
  if (empty($attribute->aid)) {
    $attributes = $config->get('attributes');
    $attribute_keys = is_array($attributes) ? array_keys($attributes) : array();
    $attribute->aid = 1;
    if (!empty($attribute_keys)) {
      $attribute->aid = max($attribute_keys) + 1;
    }
  }
  $config->set("attributes.{$attribute->aid}", $attribute);
  $config->save();

  return $attribute;
}

/**
 * Save attribute to config
 *
 * @param object $option
 */
function uc_attribute_attribute_option_save($option) {
  $config = config('uc_attribute.attributes');
  // Create a unique oid across all attributes.
  if (empty($option->oid)) {
    $options = array();
    $attributes = $config->get('attributes');
    foreach ($attributes as $attribute) {
      $options += !empty($attribute['options']) ? $attribute['options'] : array();
    }
    $option_keys = is_array($options) ? array_keys($options) : array();
    $option->oid = 1;
    if (!empty($option_keys)) {
      $option->oid = max($option_keys) + 1;
    }
  }
  $config->set("attributes.{$option->aid}.options.{$option->oid}", $option);
  $config->save();
}

/**
 * Delete global attribute, cascading to all instances.
 *
 * @param int $aid
 *
 * @return bool
 */
function uc_attribute_global_attribute_cascade_delete($aid) {
  // Delete the product attributes and their options.
  // uc_attribute_subject_delete($aid, 'product');
  $attribute = uc_attribute_load($aid);
  if (!$attribute) {
    return FALSE;
  }
  $options = array_keys($attribute->options);
  if ($options) {
    db_delete('uc_product_options')
      ->condition('oid', $options, 'IN')
      ->execute();
  }
  if ($nodes = db_query("SELECT nid FROM {uc_product_attributes} WHERE aid = :aid", array(':aid' => $attribute->aid))->fetchCol()) {
    db_delete('uc_product_adjustments')
      ->condition('nid', $nodes, 'IN')
      ->execute();
  }

  db_delete('uc_product_attributes')
    ->condition('aid', $aid)
    ->execute();

  $config = config('uc_attribute.attributes');
  $classes = $config->get('classes');
  foreach ($classes as $class_name => $class_info) {
    $config->clear("classes.{$class_name}.{$aid}");
  }
  $config->clear("attributes.{$aid}");
  $config->save();

  return TRUE;
}

/**
 * Implements hook_config_create().
 */
function uc_attribute_config_create($staging_config) {
  // Do we need to do anything?
}

/**
 * Implements hook_config_update().
 */
function uc_attribute_config_update($staging_config, $active_config) {
  // If a product class is deleted, delete the attributes on the class,
  // and on the products.

  // Compare attributes and remove class, product attributes that are
  // removed.
}

/**
 * Implements hook_config_delete().
 */
function uc_attribute_config_delete($active_config) {
  // If product class is deleted, remove all attributes.

  // Remove class, product attributes that are
  // removed.
}

/**
 * Deletes an attribute from the database.
 *
 * @param int $aid
 *   Attribute ID to delete.
 *
 * @return int
 *   The Backdrop SAVED_DELETED flag.
 */
function uc_attribute_delete($aid) {
  // Delete the class attributes and their options.
  uc_attribute_class_attribute_delete($aid);

  // Delete the product attributes and their options.
  uc_attribute_product_attribute_delete($aid);

  // Delete base attributes and their options.
  config_clear('uc_attribute.attributes', "{$aid}");

  return SAVED_DELETED;
}

/**
 * Loads an attribute option from the database.
 *
 * @param int $oid
 *   Option ID to load.
 *
 * @return object
 *   The attribute option object.
 */
function uc_attribute_option_load($oid) {
  $config = config('uc_attribute.attributes');
  $attributes = $config->get('attributes');
  $option = new stdClass();
  foreach ($attributes as $attribute) {
    foreach ($attribute['options'] as $option_id => $option_info) {
      if ($option_id == $oid) {
        $option = (object) $option_info;
        continue;
      }
    }
  }
  return $option;
  //return db_query("SELECT * FROM {uc_attribute_options} WHERE oid = :oid", array(':oid' => $oid))->fetchObject();
}

/**
 * Saves an attribute object to the database.
 *
 * @param object $option
 *   The attribute option object to save.
 *
 * @return bool
 */
function uc_attribute_option_save(&$option) {
  uc_attribute_attribute_option_save($option);
  // @todo better return
  return TRUE;
}

/**
 * Deletes an attribute option from the database.
 *
 * @param int $oid
 *   Option ID to delete.
 *
 * @return int
 *   The Backdrop SAVED_DELETED flag.
 */
function uc_attribute_option_delete($oid) {
  // Delete the class attribute options.
  //uc_attribute_subject_option_delete($oid, 'class');
  uc_attribute_class_option_delete($oid);

  // Delete the product attribute options (and the adjustments!).
  uc_attribute_subject_option_delete($oid, 'product');

  // Delete base attributes and their options.
  // db_delete('uc_attribute_options')
  //   ->condition('oid', $oid)
  //   ->execute();
  uc_attribute_global_option_delete($oid);

  return SAVED_DELETED;
}

/**
 * Delete attribute from config
 *
 * @param int $aid
 * @param int $oid
 */
function uc_attribute_global_option_cascade_delete($aid, $oid) {
  // Delete the product attribute options (and the adjustments!).
  uc_attribute_product_option_delete($oid);

  $config = config('uc_attribute.attributes');
  $classes = $config->get('classes');
  foreach ($classes as $class_name => $class_info) {
    $config->clear("classes.{$class_name}.{$aid}.options.{$oid}");
  }
  $config->clear("attributes.{$aid}.options.{$oid}");
  $config->save();
}

/**
 * Saves a product/class attribute.
 *
 * @param &$attribute
 *   The product/class attribute.
 * @param string $type
 *   Is this a product or a class?
 * @param string $id
 *   The product/class ID.
 * @param bool $save_options
 *   Save the product/class attribute's options, too?
 *
 * @return int
 *   The integer result from backdrop_write_record(), or, in the case
 *   of class configuration, return SAVED_INSERT/SAVED_UPDATE.
 */
function uc_attribute_subject_save(&$attribute, $type, $id, $save_options = FALSE) {
  $return = 0;
  if ($type == 'class') {
    $return = uc_attribute_class_attribute_save($attribute, $id);
  }
  elseif ($type == 'product') {
    $return = uc_attribute_product_attribute_save($attribute, $id, $save_options);
  }
  return $return;
}

/**
 * Saves a class attribute.
 *
 * @param &$attribute
 *   The class attribute.
 * @param string $pcid
 *   The class ID.
 * @param bool $save_options
 *   Save the class attribute's options, too?
 *
 * @return int
 *   The int SAVED_INSERT or SAVED_UPDATE.
 */
function uc_attribute_class_attribute_save(&$attribute, $pcid, $save_options = FALSE) {
  $exists = uc_attribute_subject_exists($attribute->aid, 'class', $pcid);
  // First, save the options. First because if this is an insert, we'll set
  // a default option for the class attribute.
  if ($save_options && is_array($attribute->options)) {
    // Is this an insert? If so, we'll set the default option.
    if (!$exists) {
      $default_option = 0;
      // Make the first option (if any) the default.
      if (!empty($attribute->options) && is_array($attribute->options)) {
        $option = (object) reset($attribute->options);
        $default_option = $option->oid;
      }
      $attribute->default_option = $default_option;
    }
  }

  // Merge in the class attribute's ID and save.
  $attribute->pcid = $pcid;

  $config = config('uc_attribute.attributes');
  $config->set("classes.{$pcid}.{$attribute->aid}", $attribute);
  $config->save();

  return $exists ? SAVED_UPDATED : SAVED_NEW;
}

/**
 * Saves a product attribute.
 *
 * @param &$attribute
 *   The product attribute.
 * @param string $nid
 *   The product ID.
 * @param bool $save_options
 *   Save the product attribute's options, too?
 *
 * @return int
 *   The integer result from backdrop_write_record().
 */
function uc_attribute_product_attribute_save(&$attribute, $nid, $save_options = FALSE) {
  // Insert or update?
  $key = uc_attribute_subject_exists($attribute->aid, 'product', $nid) ? array('aid', 'nid') : array();

  // First, save the options. First because if this is an insert, we'll set
  // a default option for the product/class attribute.
  if ($save_options && is_array($attribute->options)) {
    foreach ($attribute->options as $option) {
      // Sanity check!
      $option = (object) $option;
      uc_attribute_subject_option_save($option, 'product', $nid);
    }

    // Is this an insert? If so, we'll set the default option.
    if (empty($key)) {
      $default_option = 0;
      // Make the first option (if any) the default.
      if (!empty($attribute->options) && is_array($attribute->options)) {
        $option = (object) reset($attribute->options);
        $default_option = $option->oid;
      }
      $attribute->default_option = $default_option;
    }
  }

  // Merge in the product/class attribute's ID and save.
  $attribute->nid = $nid;
  $result = backdrop_write_record('uc_product_attributes', $attribute, $key);

  return $result;
}

/**
 * Deletes an attribute and all options associated with it.
 *
 * @param int $aid
 *   The base attribute ID.
 * @param string $type
 *   Is this a product or a class?
 * @param $id
 *   The product/class ID.
 *
 * @return int
 *   The Backdrop SAVED_DELETED flag.
 */
function uc_attribute_subject_delete($aid, $type, $id = NULL) {
  if ($type == 'class') {
    return uc_attribute_class_attribute_delete($aid);
  }
  elseif ($type == 'product') {
    return uc_attribute_product_attribute_delete($aid, $id);
  }
}

/**
 * Delete a class attribute
 *
 * @param int $aid
 *
 * @return int
 *   The Backdrop SAVED_DELETED flag.
 */
function uc_attribute_class_attribute_delete($aid) {
  $config = config('uc_attribute.attributes');
  $classes = $config->get('classes');
  foreach ($classes as $class_name => $class_info) {
    $config->clear("classes.{$class_name}.{$aid}");
  }
  $config->clear("attributes.{$aid}");
  $config->save();

  return SAVED_DELETED;
}

/**
 * Delete a product attribute
 *
 * @param int $aid
 *
 * @return int
 *   The Backdrop SAVED_DELETED flag.
 */
function uc_attribute_product_attribute_delete($aid, $id = NULL) {
  $query = db_select('uc_attribute_options', 'a')
    ->fields('a', array('oid'));
  $query->join('uc_product_options', 'subject', 'a.oid = subject.oid');

  // Base conditions, and an ID check if necessary.
  $conditions = db_and()
    ->condition('aid', $aid);
  if ($id) {
    $conditions->condition('nid', $id);
  }

  $query->condition($conditions);
  $result = $query->execute();
  while ($oid = $result->fetchField()) {
    // Don't delete the adjustments one at a time. We'll do it in bulk soon for
    // efficiency.
    uc_attribute_subject_option_delete($oid, 'product', $id, FALSE);
  }
  db_delete('uc_product_attributes')
    ->condition($conditions)
    ->execute();

  // If this is a product attribute, wipe any associated adjustments.
  uc_attribute_adjustments_delete(array(
    'aid' => $aid,
    'nid' => $id,
  ));

  return SAVED_DELETED;
}

/**
 * Loads a product/class attribute option.
 *
 * @param int $oid
 *   The product/class attribute option ID.
 * @param string $type
 *   Is this a product or a class?
 * @param int $id
 *   The product/class ID.
 *
 * @return object
 *   An object containing the product/class attribute option.
 */
function uc_attribute_subject_option_load($oid, $type, $id) {
  if ($type == 'product') {
    $return = uc_attribute_product_option_load($oid, $id);
  }
  elseif ($type == 'class') {
    $return = uc_attribute_class_option_load($oid, $id);
  }

  return $return;
}

/**
 * Loads a class attribute option.
 *
 * @param int $oid
 *   The class attribute option ID.
 * @param int $id
 *   The class ID.
 *
 * @return object
 *   An object containing the class attribute option.
 */
function uc_attribute_class_option_load($oid, $pcid) {
  $config = config('uc_attribute.attributes');
  $class_attributes = $config->get("classes.{$pcid}");
  foreach ($class_attributes as $class_attribute) {
    if (!empty($class_attribute['options'][$oid])) {
      return $class_attribute['options'][$oid];
    }
  }
}

/**
 * Loads a product attribute option.
 *
 * @param int $oid
 *   The product attribute option ID.
 * @param int $id
 *   The product/class ID.
 *
 * @return object
 *   An object containing the product/class attribute option.
 */
function uc_attribute_product_option_load($oid, $nid) {
  $query = db_select('uc_product_options', 'po');
  //$query->leftJoin('uc_attribute_options', 'ao', 'po.oid = ao.oid');
  $query->fields('po', array('nid', 'oid', 'cost', 'price', 'weight', 'ordering'))
    //->fields('ao', array('name', 'aid'))
    ->condition('po.oid', $oid)
    ->condition("po.nid", $nid)
    ->orderBy('po.ordering');
    //->orderBy('ao.name');
  $result = $query->execute()->fetchObject();
  // @todo How do we get the aid? Go through all attributes and find the option?
  // $config = config('uc_attribute.attributes');
  // $global_attributes = $config->get("attributes");
  // @todo add name and sort.
  backdrop_sort($result, array('ordering' => SORT_NUMERIC, 'name' => SORT_STRING));
  return $result;
}

/**
 * Saves a product/class attribute option.
 *
 * @param &$option
 *   The product/class attribute option.
 * @param string $type
 *   Is this a product or a class?
 * @param int $id
 *   The product/class ID.
 *
 * @return int
 *   The integer result from backdrop_write_record().
 */
function uc_attribute_subject_option_save(&$option, $type, $id) {
  if ($type == 'class') {
    $result = uc_attribute_class_option_save($option, $id);
  }
  elseif ($type == 'product') {
    $result = uc_attribute_product_option_save($option, $id);
  }

  return $result;
}

/**
 * Saves a class attribute option.
 *
 * @param &$option
 *   The class attribute option.
 * @param int $pcid
 *   The class ID.
 *
 * @return int
 *   SAVED_INSERT or SAVED_UPDATE
 */
function uc_attribute_class_option_save(&$option, $pcid) {
  // Insert or update?
  $exists = uc_attribute_class_option_exists($option->oid, $pcid);

  // Merge in the class attribute option's ID, and save.
  $option->pcid = $pcid;
  $config = config('uc_attribute.attributes');
  // @todo make sure $option->aid exists.
  $config->set("classes.{$pcid}.{$option->aid}.options.{$option->oid}", $option);
  $config->save();

  return $exists ? SAVED_UPDATED : SAVED_NEW;
}

/**
 * Saves a product attribute option.
 *
 * @param &$option
 *   The product attribute option.
 * @param int $nid
 *   The product ID.
 *
 * @return int
 *   The integer result from backdrop_write_record().
 */
function uc_attribute_product_option_save(&$option, $nid) {
  // Insert or update?
  $key = uc_attribute_product_option_exists($option->oid, $nid) ? array('oid', 'nid') : array();

  // Merge in the product/class attribute option's ID, and save.
  $option->product = $nid;
  $result = backdrop_write_record('uc_product_options', $option, $key);

  return $result;
}

/**
 * Deletes a product/class attribute option.
 *
 * @param $oid
 *   The base attribute's option ID.
 * @param string $type
 *   Is this a product or a class?
 * @param int $id
 *   The product/class ID.
 *
 * @return int
 *   The Backdrop SAVED_DELETED flag.
 */
function uc_attribute_subject_option_delete($oid, $type, $id = NULL, $adjustments = TRUE) {
  if ($type == 'class') {
    uc_attribute_class_option_delete($oid, $id);
  }
  elseif ($type == 'product') {
    uc_attribute_product_option_delete($oid, $id);
  }

  return SAVED_DELETED;
}

/**
 * Deletes a class attribute option.
 *
 * @param $oid
 *   The base attribute's option ID.
 * @param int $pcid
 *   The class ID.
 *
 * @return int
 *   The Backdrop SAVED_DELETED flag.
 */
function uc_attribute_class_option_delete($oid, $pcid = NULL) {
  $config = config('uc_attribute.attributes');
  if ($pcid) {
    $class_attributes = $config->get("classes.{$pcid}");
    foreach ($class_attributes['options'] as $oid => $option) {
      $config->clear("classes.{$pcid}.{$class_attributes['aid']}.options.{$oid}");
    }
  }
  else {
    $classes = $config->get('classes');
    foreach ($classes as $class_name => $class_info) {
      foreach ($class_info as $aid => $attribute_info) {
        foreach ($attribute_info['options'] as $oid => $option) {
          $config->clear("classes.{$class_name}.{$aid}.options.{$oid}");
        }
      }
    }
  }
  $config->save();

  return SAVED_DELETED;
}

/**
 * Deletes a product attribute option.
 *
 * @param $oid
 *   The base attribute's option ID.
 * @param int $id
 *   The product ID.
 *
 * @return int
 *   The Backdrop SAVED_DELETED flag.
 */
function uc_attribute_product_option_delete($oid, $nid = NULL, $adjustments = TRUE) {
  // Delete the option.
  $query = db_delete('uc_product_options')
    ->condition('oid', $oid);

  // Base conditions, and an ID check if necessary.
  if ($nid) {
    $query->condition('nid', $nid);
  }

  $query->execute();

  // If this is a product, clean up the associated adjustments.
  if ($adjustments) {
    uc_attribute_adjustments_delete(array(
      'aid' => uc_attribute_option_load($oid)->aid,
      'oid' => $oid,
      'nid' => $nid,
    ));
  }

  return SAVED_DELETED;
}

/**
 * Deletes a global attribute option.
 *
 * @param $oid
 *   The base attribute's option ID.
 *
 * @return int
 *   The Backdrop SAVED_DELETED flag.
 */
function uc_attribute_global_option_delete($oid) {
  $config = config('uc_attribute.attributes');
  $attributes = $config->get('attributes');
  foreach ($attributes as $aid => $attribute_info) {
    foreach ($attribute_info['options'] as $oid => $option) {
      $config->clear("attributes.{$aid}.options.{$oid}");
    }
  }
  $config->save();
}

/**
 * Deletes an attribute adjustment.
 *
 * @param array $fields
 *   Fields used to build a condition to delete adjustments against. Fields
 *   currently handled are 'aid', 'oid', and 'nid'.
 *
 * @return int
 *   The Backdrop SAVED_DELETED flag.
 */
function uc_attribute_adjustments_delete(array $fields) {
  // Build the serialized string to match against adjustments.
  $match = '';
  if (!empty($fields['aid'])) {
    $match .= serialize((integer) $fields['aid']);
  }
  if (!empty($fields['oid'])) {
    $match .= serialize((string) $fields['oid']);
  }

  // Assemble the conditions and args for the SQL.
  $query = db_delete('uc_product_adjustments');

  // If we have to match aid or oid...
  if ($match) {
    $query->condition('combination', '%' . db_like($match) . '%', 'LIKE');
  }

  // If we've got a node ID to match.
  if (!empty($fields['nid'])) {
    $query->condition('nid', $fields['nid']);
  }

  // Delete what's necessary.
  if ($query->conditions()) {
    $query->execute();
  }

  return SAVED_DELETED;
}

/**
 * Checks if a product/class attribute exists.
 *
 * @param int $aid
 *   The base attribute ID.
 * @param string $type
 *   Is this a product or a class?
 * @param int $id
 *   The product/class attribute's ID.
 *
 * @return bool
 *   TRUE if the attribute exists.
 */
function uc_attribute_subject_exists($aid, $type, $id) {
  if ($type == 'class') {
    $exists = uc_attribute_class_exists($aid, $id);
  }
  elseif ($type == 'product') {
    $exists = uc_attribute_product_exists($aid, $id);
  }

  return $exists;
}

/**
 * Checks if a class attribute exists.
 *
 * @param int $aid
 *   The base attribute ID.
  * @param int $pcid
 *   The class attribute's ID.
 *
 * @return bool
 *   TRUE if the attribute exists.
 */
function uc_attribute_class_exists($aid, $pcid) {
  $config = config('uc_attribute.attributes');
  $class_attribute = $config->get("classes.{$pcid}.{$aid}");
  return !empty($class_attribute);
}

/**
 * Checks if a product/class attribute exists.
 *
 * @param int $aid
 *   The base attribute ID.
 * @param int $nid
 *   The product attribute's ID.
 *
 * @return bool
 *   TRUE if the attribute exists.
 */
function uc_attribute_product_exists($aid, $nid) {
  $query = db_select('uc_product_attributes', 'a')
    ->fields('a', array('aid'))
    ->condition('aid', $aid)
    ->condition('nid', $nid);
  return FALSE !== $query->execute()->fetchField();
}

/**
 * Checks if a product/class attribute option exists.
 *
 * @param int $oid
 *   The base attribute option ID.
 * @param int $id
 *   The product/class attribute option's ID.
 * @param string $type
 *   Is this a product or a class?
 *
 * @return bool
 *   TRUE if the attribute option exists.
 */
function uc_attribute_subject_option_exists($oid, $type, $id) {
  if ($type == 'class') {
    $exists = uc_attribute_class_exists($oid, $id);
  }
  elseif ($type == 'product') {
    $exists = uc_attribute_product_exists($oid, $id);
  }

  return $exists;
}

/**
 * Checks if a class attribute option exists.
 *
 * @param int $oid
 *   The base attribute option ID.
 * @param int $pcid
 *   The class attribute option's ID.
 *
 * @return bool
 *   TRUE if the attribute option exists.
 */
function uc_attribute_class_option_exists($oid, $pcid) {
  $config = config('uc_attribute.attributes');
  $class_attributes = $config->get("classes.{$pcid}");
  $exists = FALSE;
  foreach ($class_attributes as $aid => $class_attribute) {
    if (!empty($class_attribute['options'][$oid])) {
      $exists = TRUE;
      continue;
    }
  }
  return $exists;
}

/**
 * Checks if a product attribute option exists.
 *
 * @param int $oid
 *   The base attribute option ID.
 * @param int $nid
 *   The product attribute option's ID.
 * @return bool
 *   TRUE if the attribute option exists.
 */
function uc_attribute_product_option_exists($oid, $nid) {
  $query = db_select('uc_product_options', 'o')
    ->fields('o', array('oid'))
    ->condition('oid', $oid)
    ->condition('nid', $nid);
  return FALSE !== $query->execute()->fetchField();
}

/**
 * Loads all attributes associated with a product node.
 *
 * @param int $nid
 *   The product node id.
 *
 * @return array
 *   The attributes.
 */
function uc_product_get_attributes($nid) {
  $attributes = array();

  $result = db_query("SELECT upa.aid FROM {uc_product_attributes} upa WHERE upa.nid = :nid ORDER BY upa.ordering", array(':nid' => $nid));

  // @todo order by ordering, name.
  backdrop_sort($result, array('ordering' => SORT_NUMERIC, 'name' => SORT_STRING));

  foreach ($result as $attribute) {
    $attributes[$attribute->aid] = uc_attribute_product_load($attribute->aid, $nid);
  }

  return $attributes;
}

/**
 * Loads all attributes associated with a product class.
 *
 * @param int $pcid
 *   The product class id.
 *
 * @return array
 *   An aarray of attribute objects.
 */
function uc_class_get_attributes($pcid) {
  $attributes = array();

  $config = config('uc_attribute.attributes');
  $class_attributes = $config->get("classes.{$pcid}");
  foreach ($class_attributes as $aid => $class_attribute) {
    $global_attribute = $config->get("attributes.{$aid}");
    $class_attribute['name'] = $global_attribute['name'];
    $attributes[$aid] = (object) $class_attribute;
  }

  // @todo order by ordering, name.
  backdrop_sort($result, array('ordering' => SORT_NUMERIC, 'name' => SORT_STRING));

  return $attributes;
}

/**
 * Loads all attributes associated with a product class.
 *
 * @param int $pcid
 *   The product class id.
 *
 * @return array
 *   Array of attributes objects.
 */
function uc_class_get_attributes_config($pcid) {
  $attributes = array();

  $config = config('uc_attribute.attributes');
  $class_attributes = $config->get("classes.{$pcid}");
  if ($class_attributes) {
    $attributes = $class_attributes;
    foreach ($class_attributes as $aid => $class_attribute) {
      $attribute_global = $config->get("attributes.{$aid}");
      $class_attribute['name'] = $attribute_global['name'];
      $oid = 0;
      if (isset($attribute_global['options'])) {
        if ($option = reset($attribute_global['options'])) {
          $oid = $option['oid'];
        }
      }
      $class_attribute['default_option'] = $oid;
      $attributes[$aid] = (object) $class_attribute;
    }
  }

  return $attributes;
}

/**
 * Loads all attributes associated with a product class.
 *
 * @param int $pcid
 *   The product class id.
 *
 * @return array
 *   The attributes.
 */
function uc_class_get_attributes_options_config($pcid) {
  $class_attributes = array();

  $config = config('uc_attribute.attributes');
  // $attributes = $config->get("attributes");
  $class_attributes = $config->get("classes.{$pcid}");
  foreach ($class_attributes as $id => $attribute) {
    if (!empty($attribute['default_option'])) {
      $default_option = $attribute['options'][$attribute['default_option']];
      // $attributes[$id]['default_label'] = $default_option['name'];
      // $attributes[$id]['default_ordering'] = $default_option['ordering'];
      // $attributes[$id]['default_required'] = $default_option['required'];
      // $attributes[$id]['default_display'] = $default_option['display'];
    }
  }

  return $class_attributes;
}

/**
 * Gets the options chosen for a product that is in the cart.
 *
 * @param mixed $item
 *   An element of the array returned by uc_cart_get_contents.
 *
 * @return array
 *   Array of options chosen by a customer, indexed by attribute ids. Each
 *   element stores the attribute name and the option object chosen.
 */
function _uc_cart_product_get_options($item) {
  $options = array();
  if (empty($item->data)) {
    return $options;
  }
  $data = $item->data;
  $node = node_load($item->nid);

  $index = 0;
  if (!empty($data['attributes']) && is_array($data['attributes'])) {
    foreach ($data['attributes'] as $aid => $selected) {
      if (isset($node->attributes[$aid])) {
        $attribute = $node->attributes[$aid];
        $name = _uc_attribute_get_name($attribute);
        // Only discrete options can affect the price of an item.
        if ($attribute->display && count($attribute->options)) {
          // There may be many selected options, or just one.
          foreach ((array) $selected as $oid) {
            if ($oid > 0) {
              $options[$index] = (array) $attribute->options[$oid];
              $options[$index]['attribute'] = $name;
              $index++;
            }
          }
        }
        else {
          // Handle textfield attributes.
          $options[$index] = array(
            'attribute' => $name,
            'aid' => $aid,
            'oid' => 0,
            'name' => $selected,
            'cost' => 0,
            'price' => 0,
            'weight' => 0,
          );
        }
        $index++;
      }
    }
  }
  else {
    $options = array();
  }
  return $options;
}

/**
 * Ajax callback for attribute selection form elements.
 */
function uc_attribute_option_ajax($form, $form_state) {
  $parents = $form_state['triggering_element']['#array_parents'];
  $wrapper = '#' . $form_state['triggering_element']['#ajax']['wrapper'];
  while ($key = array_pop($parents)) {
    if ($key == 'attributes') {
      array_push($parents, $key);
      $element = backdrop_array_get_nested_value($form, $parents);
      $commands[] = ajax_command_replace($wrapper, backdrop_render($element));
      break;
    }
  }
  if (strpos($form['#form_id'], 'add_to_cart_form') !== FALSE) {
    $commands = array_merge($commands, uc_product_view_ajax_commands($form_state, array('display_price', 'weight', 'cost')));
  }
  $commands[] = ajax_command_prepend($wrapper, theme('status_messages'));
  return array('#type' => 'ajax', '#commands' => $commands);
}

/**
 * Helper function for uc_attribute_form_alter().
 *
 * @param $id
 *   The unique id to use to wrap these form elements.
 * @param &$product
 *   The product node for which the attribute form elements are to be attached.
 * @param bool $use_ajax
 *   TRUE to add ajax to the form. Note that ajax may be added even if this is
 *   FALSE, if there are multiple attributes and one or more of them is set to
 *   display total price.
 *
 * @return array
 *   Form API array with attribute elements to add to the product form.
 *
 * @see theme_uc_attribute_add_to_cart()
 * @see uc_attribute_option_ajax()
 */
function _uc_attribute_alter_form($id, &$product, $use_ajax) {
  // If the product doesn't have attributes, return the form as it is.
  if (empty($product->attributes) || !is_array($product->attributes)) {
    return array();
  }

  $nid = $product->nid;
  $attributes = $product->attributes;
  $priced_attributes = uc_attribute_priced_attributes($nid);

  // At this point, $product->data is the node author's userdata
  // as a string, as populated by user_node_load(). We don't need that.
  if (empty($product->data) || !is_array($product->data)) {
    $product->data = array();
  }

  // If the form is being built for the first time, populate attributes
  // with their default values.
  if (!isset($product->data['attributes'])) {
    $values = array();
    foreach ($priced_attributes as $aid) {
      if (!$attributes[$aid]->required && ($attributes[$aid]->display == 1 || $attributes[$aid]->display == 2)) {
        $values[$aid] = $attributes[$aid]->default_option;
      }
    }
    if (!empty($values)) {
      $data = $product->data;
      $data['attributes'] = $values;
      if (isset($product->qty)) {
        // Preserve the quantity (for product-kit sub-products).
        $qty = $product->qty;
      }
      $product = uc_product_load_variant($product->nid, $data);
      if (isset($qty)) {
        $product->qty = $qty;
      }
    }
  }

  // Initialize the form element.
  $form_attributes = array(
    '#theme' => 'uc_attribute_add_to_cart',
    '#id' => $id,
  );

  $price_format = config_get('uc_attribute.settings', 'uc_attribute_option_price_format');

  // Loop through each product attribute and generate its form element.
  foreach ($attributes as $attribute) {
    // Build the attribute's options array.
    $options = array();
    foreach ($attribute->options as $option) {
      $display_price = '';
      if (in_array($attribute->aid, $priced_attributes)) {
        $data = array('display_only' => TRUE) + $product->data;
        if (empty($data['attributes'])) {
          $data['attributes'] = array();
        }
        switch ($price_format) {
          case 'total':
            // Only display total price for non-checkbox options.
            // !TODO Fix attribute option total price display for product kits.
            if ($attribute->display != 3 && !isset($product->data['kit_id'])) {
              $use_ajax = $use_ajax || (count($priced_attributes) > 1);
              $data['attributes'] = array($attribute->aid => $option->oid) + $data['attributes'];
              $variant = node_view(uc_product_load_variant($product->nid, $data), 'teaser');
              $display_price = uc_currency_format($variant['display_price']['#value']);
              break;
            }
          case 'adjustment':
            if ($attribute->display == 3 || !$use_ajax) {
              // For checkboxes, or if the node totals are not being updated,
              // we compare this attribute against base price.
              // only build the base once.
              if (empty($base)) {
                unset($data['attributes']);
                $base = node_view(uc_product_load_variant($product->nid, $data), 'teaser');
              }
              $data['attributes'] = array($attribute->aid => $option->oid);
              $variant = node_view(uc_product_load_variant($product->nid, $data), 'teaser');
              $adjustment = $variant['display_price']['#value'] - $base['display_price']['#value'];
            }
            else {
              // Otherwise we compare against current total price.
              if (empty($selected)) {
                $selected = node_view(uc_product_load_variant($product->nid, $data), 'teaser');
              }
              $data['attributes'] = array($attribute->aid => $option->oid) + $data['attributes'];
              $variant = node_view(uc_product_load_variant($product->nid, $data), 'teaser');
              $adjustment = $variant['display_price']['#value'] - $selected['display_price']['#value'];
            }
            if ($adjustment != 0) {
              $display_price = $adjustment > 0 ? '+' : '-';
              $display_price .= uc_currency_format(abs($adjustment));
            }
            break;
        }
      }

      // Select options are check_plain()ed, but radio button labels are not.
      $options[$option->oid] = theme('uc_attribute_option', array(
        'option' => $attribute->display == 2 ? check_plain($option->name) : $option->name,
        'price' => $display_price,
      ));
    }

    if (count($attribute->options) && $attribute->display > 0) {
      if ($attribute->required) {
        if ($attribute->display == 1) {
          $options = array('' => t('Please select')) + $options;
        }
        $attribute->default_option = NULL;
      }
      $attr_type = '';
      switch ($attribute->display) {
        case 1:
          $attr_type = 'select';
          break;

        case 2:
          $attr_type = 'radios';
          break;

        case 3:
          $attr_type = 'checkboxes';
          $attribute->default_option = array();
          break;
      }
      $form_attributes[$attribute->aid] = array(
        '#type' => $attr_type,
        '#default_value' => $attribute->default_option,
        '#options' => $options,
      );
      if ($use_ajax) {
        $form_attributes[$attribute->aid]['#ajax'] = array(
          'callback' => 'uc_attribute_option_ajax',
          'wrapper' => $id,
        );
      }
    }
    elseif ($attribute->display > 0) {
      $form_attributes[$attribute->aid] = array(
        '#type' => 'textfield',
        '#default_value' => '',
      );
      if (!$attribute->required && isset($attribute->options[$attribute->default_option])) {
        $form_attributes[$attribute->aid]['#default_value'] = $attribute->options[$attribute->default_option]->name;
      }
    }
    else {
      $form_attributes[$attribute->aid] = array(
        '#type' => 'textfield',
        '#default_value' => '',
      );
    }

    $name = _uc_attribute_get_name($attribute, FALSE);
    if (!is_null($name)) {
      $form_attributes[$attribute->aid]['#title'] = check_plain($name);
    }

    $form_attributes[$attribute->aid]['#description'] = filter_xss($attribute->description);
    $form_attributes[$attribute->aid]['#required'] = $attribute->required;
  }

  return $form_attributes;
}

/**
 * Returns an array of display types used as options when creating attributes.
 *
 * @return array
 *   Array of display types used as options when creating attributes.
 */
function _uc_attribute_display_types() {
  return array(
    0 => t('Text field'),
    1 => t('Select box'),
    2 => t('Radio buttons'),
    3 => t('Checkboxes'),
  );
}

/**
 * Gets the price affecting attributes for a product.
 *
 * @param int $nid
 *   The nid of a product.
 *
 * @return array
 *   Array of attribute ids that have price affecting options.
 */
function uc_attribute_priced_attributes($nid) {
  $aids = db_query("SELECT DISTINCT (pa.aid) FROM {uc_product_attributes} pa INNER JOIN {uc_attribute_options} ao ON ao.aid = pa.aid INNER JOIN {uc_product_options} po ON (po.oid = ao.oid AND po.nid = pa.nid) WHERE pa.nid = :nid AND po.price <> :price AND pa.display <> :display", array(':nid' => $nid, ':price' => 0, ':display' => 0))->fetchCol();

  return $aids;
}

/**
 * Returns the attribute name to display.
 *
 * An attribute with a label set returns that label except when set to
 * '<none>' . In this case, a NULL is returned. The $title argument forces the
 * function to return the name property instead of label when label is set to
 * '<none>'.
 *
 * The NULL return value is typically used by forms so they know to hide the
 * #title property of the element.
 *
 * @param object $attribute
 *   Attribute object.
 * @param bool $title
 *   TRUE indicates the function is to return the attribute name when its label
 *   is set to '<none>'.
 *
 * @return string|null
 *   When the attribute label is set and not '<none>', it is returned.
 *   Otherwise, the attribute name is returned when $title is TRUE and NULL is
 *   returned when $title is FALSE.
 */
function _uc_attribute_get_name($attribute, $title = TRUE) {
  if (!$title && $attribute->label == '<none>') {
    return NULL;
  }
  else {
    return (empty($attribute->label) || ($attribute->label == '<none>' && $title) ? $attribute->name : $attribute->label);
  }
}

/**
 * Implements hook_i18n_string_info().
 */
function uc_attribute_i18n_string_info() {
  $groups['uc_attribute'] = array(
    'title' => t('Ubercart attributes'),
    'description' => t('Translatable Ubercart attributes'),
    'format' => FALSE,
    'list' => TRUE,
  );
  return $groups;
}

/**
 * Refreshes translated attribute and option strings.
 */
function uc_attribute_i18n_string_refresh() {
  $attributes = config_get('uc_attribute.attributes', 'attributes');
  foreach ($attributes as $attribute) {
    i18n_string_update('uc_attribute:attribute:' . $attribute['aid'] . ':name', $attribute['name']);
    i18n_string_update('uc_attribute:attribute:' . $attribute['aid'] . ':label', $attribute['label']);
    i18n_string_update('uc_attribute:attribute:' . $attribute['aid'] . ':description', $attribute['description']);

    foreach ($attributes['options'] as $option) {
      i18n_string_update('uc_attribute:option:' . $option['oid'] . ':name', $option['name']);
    }
  }

  return TRUE;
}

/**
 * Translates an attribute.
 *
 * @param &$attribute
 *   The attribute object to translate.
 */
function uc_attribute_translate(&$attribute) {
  if (function_exists('i18n_string')) {
    $attribute->name        = i18n_string('uc_attribute:attribute:' . $attribute->aid . ':name', $attribute->name);
    $attribute->label       = i18n_string('uc_attribute:attribute:' . $attribute->aid . ':label', $attribute->label);
    $attribute->description = i18n_string('uc_attribute:attribute:' . $attribute->aid . ':description', $attribute->description);

    foreach ($attribute->options as &$option) {
      $option->name = i18n_string('uc_attribute:option:' . $option->oid . ':name', $option->name);
    }
  }
}
